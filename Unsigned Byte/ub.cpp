/*
 *	 ub.cpp
 *	 Generated by sql2class v1.8 by (C) AH 2000-2006
 *	  using command line
 *	  $ sql2class.exe -lib ub -sqlite ub.sql -namespace db -overwrite -getset
 *	 Date: Sun Aug 19 13:02:35 2007
 */

/*
Copyright (C) 2001-2006  Anders Hedstrom (grymse@alhem.net)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/
#include "ub.h"

namespace db {

/**
 **  Begin class 'Accounts'
 **/

Accounts::Accounts(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Accounts::Accounts(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Accounts::Accounts(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Accounts::Accounts(Database& db,long i_accountid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Accounts where ";
	{
		char slask[100];
		sprintf(slask,"accountid='%ld'",i_accountid);
		sql += slask;
	}
	spawn(sql);
}


Accounts::~Accounts()
{
}


void Accounts::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Accounts::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Accounts(name,password)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", '" + q.GetDatabase().safestr(this -> password) + "'";
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	accountid = inserted_id;
	return inserted_id;
}


void Accounts::update()
{
	update(this -> accountid);
}


void Accounts::update(long i_accountid)
{
	Query q(*database);
	std::string sql;
	sql += "update Accounts set name='" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", password='" + q.GetDatabase().safestr(this -> password) + "'";
	{
		char slask[200];
		sprintf(slask," where accountid='%ld'",i_accountid);
		sql += slask;
	}
	q.execute(sql);
}


void Accounts::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Accounts::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Accounts where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," accountid='%ld'",this -> accountid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Accounts::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<ACCOUNTS>";
	sprintf(slask,"<ACCOUNTID>%ld</ACCOUNTID>",this -> accountid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<PASSWORD>" + q.GetDatabase().xmlsafestr(this -> password) + "</PASSWORD>";
	dest += "</ACCOUNTS>";
	return dest;
}


std::string Accounts::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<ACCOUNTS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<ACCOUNTID>%ld</ACCOUNTID>",this -> accountid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<PASSWORD>" + q.GetDatabase().xmlsafestr(this -> password) + "</PASSWORD>";
	dest += "</ACCOUNTS>";
	return dest;
}


size_t Accounts::num_cols()
{
	return 3;
}


void Accounts::clear()
{
	this -> accountid = 0;
	this -> name = "";
	this -> password = "";
}


void Accounts::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select accountid,name,password " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> accountid = q.getval(0);																				// 0 - accountid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> password = q.getstr(2);																				// 2 - password TEXT
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Accounts::spawn(Query *qd,int offset)
{
	clear();

	this -> accountid = qd -> getval(0 + offset);																				// 0 - accountid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> password = qd -> getstr(2 + offset);																				// 2 - password TEXT
}


// End of implementation of class 'Accounts'

} // End of namespace
namespace db {

/**
 **  Begin class 'Areas'
 **/

Areas::Areas(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Areas::Areas(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Areas::Areas(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Areas::Areas(Database& db,long i_areaid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Areas where ";
	{
		char slask[100];
		sprintf(slask,"areaid='%ld'",i_areaid);
		sql += slask;
	}
	spawn(sql);
}


Areas::~Areas()
{
}


void Areas::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Areas::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Areas(name,description,height,width)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", '" + q.GetDatabase().safestr(this -> description) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> height);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> width);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	areaid = inserted_id;
	return inserted_id;
}


void Areas::update()
{
	update(this -> areaid);
}


void Areas::update(long i_areaid)
{
	Query q(*database);
	std::string sql;
	sql += "update Areas set name='" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", description='" + q.GetDatabase().safestr(this -> description) + "'";
	{
		char slask[200];
		sprintf(slask,", height=%ld",this -> height);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", width=%ld",this -> width);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where areaid='%ld'",i_areaid);
		sql += slask;
	}
	q.execute(sql);
}


void Areas::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Areas::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Areas where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," areaid='%ld'",this -> areaid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Areas::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<AREAS>";
	sprintf(slask,"<AREAID>%ld</AREAID>",this -> areaid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<DESCRIPTION>" + q.GetDatabase().xmlsafestr(this -> description) + "</DESCRIPTION>";
	sprintf(slask,"<HEIGHT>%ld</HEIGHT>",this -> height);
	dest += slask;
	sprintf(slask,"<WIDTH>%ld</WIDTH>",this -> width);
	dest += slask;
	dest += "</AREAS>";
	return dest;
}


std::string Areas::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<AREAS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<AREAID>%ld</AREAID>",this -> areaid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<DESCRIPTION>" + q.GetDatabase().xmlsafestr(this -> description) + "</DESCRIPTION>";
	sprintf(slask,"<HEIGHT>%ld</HEIGHT>",this -> height);
	dest += slask;
	sprintf(slask,"<WIDTH>%ld</WIDTH>",this -> width);
	dest += slask;
	dest += "</AREAS>";
	return dest;
}


size_t Areas::num_cols()
{
	return 5;
}


void Areas::clear()
{
	this -> areaid = 0;
	this -> name = "";
	this -> description = "";
	this -> height = 0;
	this -> width = 0;
}


void Areas::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select areaid,name,description,height,width " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> areaid = q.getval(0);																				// 0 - areaid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> description = q.getstr(2);																				// 2 - description TEXT
		this -> height = q.getval(3);																				// 3 - height INTEGER
		this -> width = q.getval(4);																				// 4 - width INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Areas::spawn(Query *qd,int offset)
{
	clear();

	this -> areaid = qd -> getval(0 + offset);																				// 0 - areaid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> description = qd -> getstr(2 + offset);																				// 2 - description TEXT
	this -> height = qd -> getval(3 + offset);																				// 3 - height INTEGER
	this -> width = qd -> getval(4 + offset);																				// 4 - width INTEGER
}


// End of implementation of class 'Areas'

} // End of namespace
namespace db {

/**
 **  Begin class 'Branches'
 **/

Branches::Branches(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Branches::Branches(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Branches::Branches(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Branches::Branches(Database& db,long i_branchid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Branches where ";
	{
		char slask[100];
		sprintf(slask,"branchid='%ld'",i_branchid);
		sql += slask;
	}
	spawn(sql);
}


Branches::~Branches()
{
}


void Branches::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Branches::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Branches(name,fkTree,fkPrimaryStat,fkSecondaryStat)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fktree);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkprimarystat);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fksecondarystat);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	branchid = inserted_id;
	return inserted_id;
}


void Branches::update()
{
	update(this -> branchid);
}


void Branches::update(long i_branchid)
{
	Query q(*database);
	std::string sql;
	sql += "update Branches set name='" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[200];
		sprintf(slask,", fkTree=%ld",this -> fktree);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkPrimaryStat=%ld",this -> fkprimarystat);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkSecondaryStat=%ld",this -> fksecondarystat);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where branchid='%ld'",i_branchid);
		sql += slask;
	}
	q.execute(sql);
}


void Branches::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Branches::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Branches where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," branchid='%ld'",this -> branchid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Branches::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<BRANCHES>";
	sprintf(slask,"<BRANCHID>%ld</BRANCHID>",this -> branchid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<FKTREE>%ld</FKTREE>",this -> fktree);
	dest += slask;
	sprintf(slask,"<FKPRIMARYSTAT>%ld</FKPRIMARYSTAT>",this -> fkprimarystat);
	dest += slask;
	sprintf(slask,"<FKSECONDARYSTAT>%ld</FKSECONDARYSTAT>",this -> fksecondarystat);
	dest += slask;
	dest += "</BRANCHES>";
	return dest;
}


std::string Branches::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<BRANCHES " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<BRANCHID>%ld</BRANCHID>",this -> branchid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<FKTREE>%ld</FKTREE>",this -> fktree);
	dest += slask;
	sprintf(slask,"<FKPRIMARYSTAT>%ld</FKPRIMARYSTAT>",this -> fkprimarystat);
	dest += slask;
	sprintf(slask,"<FKSECONDARYSTAT>%ld</FKSECONDARYSTAT>",this -> fksecondarystat);
	dest += slask;
	dest += "</BRANCHES>";
	return dest;
}


size_t Branches::num_cols()
{
	return 5;
}


void Branches::clear()
{
	this -> branchid = 0;
	this -> name = "";
	this -> fktree = 0;
	this -> fkprimarystat = 0;
	this -> fksecondarystat = 0;
}


void Branches::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select branchid,name,fkTree,fkPrimaryStat,fkSecondaryStat " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> branchid = q.getval(0);																				// 0 - branchid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> fktree = q.getval(2);																				// 2 - fktree INTEGER
		this -> fkprimarystat = q.getval(3);																				// 3 - fkprimarystat INTEGER
		this -> fksecondarystat = q.getval(4);																				// 4 - fksecondarystat INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Branches::spawn(Query *qd,int offset)
{
	clear();

	this -> branchid = qd -> getval(0 + offset);																				// 0 - branchid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> fktree = qd -> getval(2 + offset);																				// 2 - fktree INTEGER
	this -> fkprimarystat = qd -> getval(3 + offset);																				// 3 - fkprimarystat INTEGER
	this -> fksecondarystat = qd -> getval(4 + offset);																				// 4 - fksecondarystat INTEGER
}


// End of implementation of class 'Branches'

} // End of namespace
namespace db {

/**
 **  Begin class 'AccountCharacter'
 **/

AccountCharacter::AccountCharacter(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


AccountCharacter::AccountCharacter(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


AccountCharacter::AccountCharacter(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


AccountCharacter::AccountCharacter(Database& db,long i_accountcharacterid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from AccountCharacter where ";
	{
		char slask[100];
		sprintf(slask,"accountcharacterid='%ld'",i_accountcharacterid);
		sql += slask;
	}
	spawn(sql);
}


AccountCharacter::~AccountCharacter()
{
}


void AccountCharacter::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long AccountCharacter::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into AccountCharacter(fkCharacter,fkAccount)";
	{
		char slask[100];
		sprintf(slask," values(%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkaccount);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	accountcharacterid = inserted_id;
	return inserted_id;
}


void AccountCharacter::update()
{
	update(this -> accountcharacterid);
}


void AccountCharacter::update(long i_accountcharacterid)
{
	Query q(*database);
	std::string sql;
	{
		char slask[200];
		sprintf(slask,"update AccountCharacter set fkCharacter=%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkAccount=%ld",this -> fkaccount);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where accountcharacterid='%ld'",i_accountcharacterid);
		sql += slask;
	}
	q.execute(sql);
}


void AccountCharacter::save()
{
	if (new_object)
		insert();
	else
		update();
}


void AccountCharacter::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from AccountCharacter where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," accountcharacterid='%ld'",this -> accountcharacterid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string AccountCharacter::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<ACCOUNTCHARACTER>";
	sprintf(slask,"<ACCOUNTCHARACTERID>%ld</ACCOUNTCHARACTERID>",this -> accountcharacterid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKACCOUNT>%ld</FKACCOUNT>",this -> fkaccount);
	dest += slask;
	dest += "</ACCOUNTCHARACTER>";
	return dest;
}


std::string AccountCharacter::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<ACCOUNTCHARACTER " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<ACCOUNTCHARACTERID>%ld</ACCOUNTCHARACTERID>",this -> accountcharacterid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKACCOUNT>%ld</FKACCOUNT>",this -> fkaccount);
	dest += slask;
	dest += "</ACCOUNTCHARACTER>";
	return dest;
}


size_t AccountCharacter::num_cols()
{
	return 3;
}


void AccountCharacter::clear()
{
	this -> accountcharacterid = 0;
	this -> fkcharacter = 0;
	this -> fkaccount = 0;
}


void AccountCharacter::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select accountcharacterid,fkCharacter,fkAccount " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> accountcharacterid = q.getval(0);																				// 0 - accountcharacterid INTEGER
		this -> fkcharacter = q.getval(1);																				// 1 - fkcharacter INTEGER
		this -> fkaccount = q.getval(2);																				// 2 - fkaccount INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void AccountCharacter::spawn(Query *qd,int offset)
{
	clear();

	this -> accountcharacterid = qd -> getval(0 + offset);																				// 0 - accountcharacterid INTEGER
	this -> fkcharacter = qd -> getval(1 + offset);																				// 1 - fkcharacter INTEGER
	this -> fkaccount = qd -> getval(2 + offset);																				// 2 - fkaccount INTEGER
}


// End of implementation of class 'AccountCharacter'

} // End of namespace
namespace db {

/**
 **  Begin class 'CharacterBranch'
 **/

CharacterBranch::CharacterBranch(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


CharacterBranch::CharacterBranch(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


CharacterBranch::CharacterBranch(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


CharacterBranch::CharacterBranch(Database& db,long i_characterbranchid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from CharacterBranch where ";
	{
		char slask[100];
		sprintf(slask,"characterbranchid='%ld'",i_characterbranchid);
		sql += slask;
	}
	spawn(sql);
}


CharacterBranch::~CharacterBranch()
{
}


void CharacterBranch::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long CharacterBranch::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into CharacterBranch(fkCharacter,fkBranch)";
	{
		char slask[100];
		sprintf(slask," values(%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkbranch);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	characterbranchid = inserted_id;
	return inserted_id;
}


void CharacterBranch::update()
{
	update(this -> characterbranchid);
}


void CharacterBranch::update(long i_characterbranchid)
{
	Query q(*database);
	std::string sql;
	{
		char slask[200];
		sprintf(slask,"update CharacterBranch set fkCharacter=%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkBranch=%ld",this -> fkbranch);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where characterbranchid='%ld'",i_characterbranchid);
		sql += slask;
	}
	q.execute(sql);
}


void CharacterBranch::save()
{
	if (new_object)
		insert();
	else
		update();
}


void CharacterBranch::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from CharacterBranch where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," characterbranchid='%ld'",this -> characterbranchid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string CharacterBranch::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERBRANCH>";
	sprintf(slask,"<CHARACTERBRANCHID>%ld</CHARACTERBRANCHID>",this -> characterbranchid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKBRANCH>%ld</FKBRANCH>",this -> fkbranch);
	dest += slask;
	dest += "</CHARACTERBRANCH>";
	return dest;
}


std::string CharacterBranch::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERBRANCH " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<CHARACTERBRANCHID>%ld</CHARACTERBRANCHID>",this -> characterbranchid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKBRANCH>%ld</FKBRANCH>",this -> fkbranch);
	dest += slask;
	dest += "</CHARACTERBRANCH>";
	return dest;
}


size_t CharacterBranch::num_cols()
{
	return 3;
}


void CharacterBranch::clear()
{
	this -> characterbranchid = 0;
	this -> fkcharacter = 0;
	this -> fkbranch = 0;
}


void CharacterBranch::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select characterbranchid,fkCharacter,fkBranch " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> characterbranchid = q.getval(0);																				// 0 - characterbranchid INTEGER
		this -> fkcharacter = q.getval(1);																				// 1 - fkcharacter INTEGER
		this -> fkbranch = q.getval(2);																				// 2 - fkbranch INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void CharacterBranch::spawn(Query *qd,int offset)
{
	clear();

	this -> characterbranchid = qd -> getval(0 + offset);																				// 0 - characterbranchid INTEGER
	this -> fkcharacter = qd -> getval(1 + offset);																				// 1 - fkcharacter INTEGER
	this -> fkbranch = qd -> getval(2 + offset);																				// 2 - fkbranch INTEGER
}


// End of implementation of class 'CharacterBranch'

} // End of namespace
namespace db {

/**
 **  Begin class 'CharacterCluster'
 **/

CharacterCluster::CharacterCluster(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


CharacterCluster::CharacterCluster(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


CharacterCluster::CharacterCluster(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


CharacterCluster::CharacterCluster(Database& db,long i_characterclusterid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from CharacterCluster where ";
	{
		char slask[100];
		sprintf(slask,"characterclusterid='%ld'",i_characterclusterid);
		sql += slask;
	}
	spawn(sql);
}


CharacterCluster::~CharacterCluster()
{
}


void CharacterCluster::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long CharacterCluster::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into CharacterCluster()";
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	characterclusterid = inserted_id;
	return inserted_id;
}


void CharacterCluster::update()
{
	update(this -> characterclusterid);
}


void CharacterCluster::update(long i_characterclusterid)
{
	Query q(*database);
	std::string sql;
	{
		char slask[200];
		sprintf(slask," where characterclusterid='%ld'",i_characterclusterid);
		sql += slask;
	}
	q.execute(sql);
}


void CharacterCluster::save()
{
	if (new_object)
		insert();
	else
		update();
}


void CharacterCluster::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from CharacterCluster where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," characterclusterid='%ld'",this -> characterclusterid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string CharacterCluster::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERCLUSTER>";
	sprintf(slask,"<CHARACTERCLUSTERID>%ld</CHARACTERCLUSTERID>",this -> characterclusterid);
	dest += slask;
	dest += "</CHARACTERCLUSTER>";
	return dest;
}


std::string CharacterCluster::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERCLUSTER " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<CHARACTERCLUSTERID>%ld</CHARACTERCLUSTERID>",this -> characterclusterid);
	dest += slask;
	dest += "</CHARACTERCLUSTER>";
	return dest;
}


size_t CharacterCluster::num_cols()
{
	return 1;
}


void CharacterCluster::clear()
{
	this -> characterclusterid = 0;
}


void CharacterCluster::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select characterclusterid " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> characterclusterid = q.getval(0);																				// 0 - characterclusterid INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void CharacterCluster::spawn(Query *qd,int offset)
{
	clear();

	this -> characterclusterid = qd -> getval(0 + offset);																				// 0 - characterclusterid INTEGER
}


// End of implementation of class 'CharacterCluster'

} // End of namespace
namespace db {

/**
 **  Begin class 'Characters'
 **/

Characters::Characters(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Characters::Characters(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Characters::Characters(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Characters::Characters(Database& db,long i_characterid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Characters where ";
	{
		char slask[100];
		sprintf(slask,"characterid='%ld'",i_characterid);
		sql += slask;
	}
	spawn(sql);
}


Characters::~Characters()
{
}


void Characters::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Characters::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Characters(fkRace,fkRoom,name,description)";
	{
		char slask[100];
		sprintf(slask," values(%ld",this -> fkrace);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkroom);
		sql += slask;
	}
	sql += ", '" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", '" + q.GetDatabase().safestr(this -> description) + "'";
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	characterid = inserted_id;
	return inserted_id;
}


void Characters::update()
{
	update(this -> characterid);
}


void Characters::update(long i_characterid)
{
	Query q(*database);
	std::string sql;
	{
		char slask[200];
		sprintf(slask,"update Characters set fkRace=%ld",this -> fkrace);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkRoom=%ld",this -> fkroom);
		sql += slask;
	}
	sql += ", name='" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", description='" + q.GetDatabase().safestr(this -> description) + "'";
	{
		char slask[200];
		sprintf(slask," where characterid='%ld'",i_characterid);
		sql += slask;
	}
	q.execute(sql);
}


void Characters::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Characters::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Characters where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," characterid='%ld'",this -> characterid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Characters::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERS>";
	sprintf(slask,"<CHARACTERID>%ld</CHARACTERID>",this -> characterid);
	dest += slask;
	sprintf(slask,"<FKRACE>%ld</FKRACE>",this -> fkrace);
	dest += slask;
	sprintf(slask,"<FKROOM>%ld</FKROOM>",this -> fkroom);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<DESCRIPTION>" + q.GetDatabase().xmlsafestr(this -> description) + "</DESCRIPTION>";
	dest += "</CHARACTERS>";
	return dest;
}


std::string Characters::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<CHARACTERID>%ld</CHARACTERID>",this -> characterid);
	dest += slask;
	sprintf(slask,"<FKRACE>%ld</FKRACE>",this -> fkrace);
	dest += slask;
	sprintf(slask,"<FKROOM>%ld</FKROOM>",this -> fkroom);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<DESCRIPTION>" + q.GetDatabase().xmlsafestr(this -> description) + "</DESCRIPTION>";
	dest += "</CHARACTERS>";
	return dest;
}


size_t Characters::num_cols()
{
	return 5;
}


void Characters::clear()
{
	this -> characterid = 0;
	this -> fkrace = 0;
	this -> fkroom = 0;
	this -> name = "";
	this -> description = "";
}


void Characters::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select characterid,fkRace,fkRoom,name,description " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> characterid = q.getval(0);																				// 0 - characterid INTEGER
		this -> fkrace = q.getval(1);																				// 1 - fkrace INTEGER
		this -> fkroom = q.getval(2);																				// 2 - fkroom INTEGER
		this -> name = q.getstr(3);																				// 3 - name TEXT
		this -> description = q.getstr(4);																				// 4 - description TEXT
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Characters::spawn(Query *qd,int offset)
{
	clear();

	this -> characterid = qd -> getval(0 + offset);																				// 0 - characterid INTEGER
	this -> fkrace = qd -> getval(1 + offset);																				// 1 - fkrace INTEGER
	this -> fkroom = qd -> getval(2 + offset);																				// 2 - fkroom INTEGER
	this -> name = qd -> getstr(3 + offset);																				// 3 - name TEXT
	this -> description = qd -> getstr(4 + offset);																				// 4 - description TEXT
}


// End of implementation of class 'Characters'

} // End of namespace
namespace db {

/**
 **  Begin class 'CharacterSkill'
 **/

CharacterSkill::CharacterSkill(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


CharacterSkill::CharacterSkill(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


CharacterSkill::CharacterSkill(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


CharacterSkill::CharacterSkill(Database& db,long i_characterskillid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from CharacterSkill where ";
	{
		char slask[100];
		sprintf(slask,"characterskillid='%ld'",i_characterskillid);
		sql += slask;
	}
	spawn(sql);
}


CharacterSkill::~CharacterSkill()
{
}


void CharacterSkill::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long CharacterSkill::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into CharacterSkill(fkCharacter,fkBranch)";
	{
		char slask[100];
		sprintf(slask," values(%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkbranch);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	characterskillid = inserted_id;
	return inserted_id;
}


void CharacterSkill::update()
{
	update(this -> characterskillid);
}


void CharacterSkill::update(long i_characterskillid)
{
	Query q(*database);
	std::string sql;
	{
		char slask[200];
		sprintf(slask,"update CharacterSkill set fkCharacter=%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkBranch=%ld",this -> fkbranch);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where characterskillid='%ld'",i_characterskillid);
		sql += slask;
	}
	q.execute(sql);
}


void CharacterSkill::save()
{
	if (new_object)
		insert();
	else
		update();
}


void CharacterSkill::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from CharacterSkill where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," characterskillid='%ld'",this -> characterskillid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string CharacterSkill::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERSKILL>";
	sprintf(slask,"<CHARACTERSKILLID>%ld</CHARACTERSKILLID>",this -> characterskillid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKBRANCH>%ld</FKBRANCH>",this -> fkbranch);
	dest += slask;
	dest += "</CHARACTERSKILL>";
	return dest;
}


std::string CharacterSkill::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERSKILL " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<CHARACTERSKILLID>%ld</CHARACTERSKILLID>",this -> characterskillid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKBRANCH>%ld</FKBRANCH>",this -> fkbranch);
	dest += slask;
	dest += "</CHARACTERSKILL>";
	return dest;
}


size_t CharacterSkill::num_cols()
{
	return 3;
}


void CharacterSkill::clear()
{
	this -> characterskillid = 0;
	this -> fkcharacter = 0;
	this -> fkbranch = 0;
}


void CharacterSkill::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select characterskillid,fkCharacter,fkBranch " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> characterskillid = q.getval(0);																				// 0 - characterskillid INTEGER
		this -> fkcharacter = q.getval(1);																				// 1 - fkcharacter INTEGER
		this -> fkbranch = q.getval(2);																				// 2 - fkbranch INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void CharacterSkill::spawn(Query *qd,int offset)
{
	clear();

	this -> characterskillid = qd -> getval(0 + offset);																				// 0 - characterskillid INTEGER
	this -> fkcharacter = qd -> getval(1 + offset);																				// 1 - fkcharacter INTEGER
	this -> fkbranch = qd -> getval(2 + offset);																				// 2 - fkbranch INTEGER
}


// End of implementation of class 'CharacterSkill'

} // End of namespace
namespace db {

/**
 **  Begin class 'CharacterStat'
 **/

CharacterStat::CharacterStat(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


CharacterStat::CharacterStat(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


CharacterStat::CharacterStat(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


CharacterStat::CharacterStat(Database& db,long i_characterstatid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from CharacterStat where ";
	{
		char slask[100];
		sprintf(slask,"characterstatid='%ld'",i_characterstatid);
		sql += slask;
	}
	spawn(sql);
}


CharacterStat::~CharacterStat()
{
}


void CharacterStat::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long CharacterStat::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into CharacterStat(fkCharacter,fkStat)";
	{
		char slask[100];
		sprintf(slask," values(%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkstat);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	characterstatid = inserted_id;
	return inserted_id;
}


void CharacterStat::update()
{
	update(this -> characterstatid);
}


void CharacterStat::update(long i_characterstatid)
{
	Query q(*database);
	std::string sql;
	{
		char slask[200];
		sprintf(slask,"update CharacterStat set fkCharacter=%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkStat=%ld",this -> fkstat);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where characterstatid='%ld'",i_characterstatid);
		sql += slask;
	}
	q.execute(sql);
}


void CharacterStat::save()
{
	if (new_object)
		insert();
	else
		update();
}


void CharacterStat::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from CharacterStat where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," characterstatid='%ld'",this -> characterstatid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string CharacterStat::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERSTAT>";
	sprintf(slask,"<CHARACTERSTATID>%ld</CHARACTERSTATID>",this -> characterstatid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKSTAT>%ld</FKSTAT>",this -> fkstat);
	dest += slask;
	dest += "</CHARACTERSTAT>";
	return dest;
}


std::string CharacterStat::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERSTAT " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<CHARACTERSTATID>%ld</CHARACTERSTATID>",this -> characterstatid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKSTAT>%ld</FKSTAT>",this -> fkstat);
	dest += slask;
	dest += "</CHARACTERSTAT>";
	return dest;
}


size_t CharacterStat::num_cols()
{
	return 3;
}


void CharacterStat::clear()
{
	this -> characterstatid = 0;
	this -> fkcharacter = 0;
	this -> fkstat = 0;
}


void CharacterStat::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select characterstatid,fkCharacter,fkStat " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> characterstatid = q.getval(0);																				// 0 - characterstatid INTEGER
		this -> fkcharacter = q.getval(1);																				// 1 - fkcharacter INTEGER
		this -> fkstat = q.getval(2);																				// 2 - fkstat INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void CharacterStat::spawn(Query *qd,int offset)
{
	clear();

	this -> characterstatid = qd -> getval(0 + offset);																				// 0 - characterstatid INTEGER
	this -> fkcharacter = qd -> getval(1 + offset);																				// 1 - fkcharacter INTEGER
	this -> fkstat = qd -> getval(2 + offset);																				// 2 - fkstat INTEGER
}


// End of implementation of class 'CharacterStat'

} // End of namespace
namespace db {

/**
 **  Begin class 'CharacterTree'
 **/

CharacterTree::CharacterTree(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


CharacterTree::CharacterTree(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


CharacterTree::CharacterTree(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


CharacterTree::CharacterTree(Database& db,long i_charactertreeid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from CharacterTree where ";
	{
		char slask[100];
		sprintf(slask,"charactertreeid='%ld'",i_charactertreeid);
		sql += slask;
	}
	spawn(sql);
}


CharacterTree::~CharacterTree()
{
}


void CharacterTree::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long CharacterTree::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into CharacterTree(fkCharacter,fkTree)";
	{
		char slask[100];
		sprintf(slask," values(%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fktree);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	charactertreeid = inserted_id;
	return inserted_id;
}


void CharacterTree::update()
{
	update(this -> charactertreeid);
}


void CharacterTree::update(long i_charactertreeid)
{
	Query q(*database);
	std::string sql;
	{
		char slask[200];
		sprintf(slask,"update CharacterTree set fkCharacter=%ld",this -> fkcharacter);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkTree=%ld",this -> fktree);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where charactertreeid='%ld'",i_charactertreeid);
		sql += slask;
	}
	q.execute(sql);
}


void CharacterTree::save()
{
	if (new_object)
		insert();
	else
		update();
}


void CharacterTree::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from CharacterTree where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," charactertreeid='%ld'",this -> charactertreeid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string CharacterTree::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERTREE>";
	sprintf(slask,"<CHARACTERTREEID>%ld</CHARACTERTREEID>",this -> charactertreeid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKTREE>%ld</FKTREE>",this -> fktree);
	dest += slask;
	dest += "</CHARACTERTREE>";
	return dest;
}


std::string CharacterTree::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CHARACTERTREE " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<CHARACTERTREEID>%ld</CHARACTERTREEID>",this -> charactertreeid);
	dest += slask;
	sprintf(slask,"<FKCHARACTER>%ld</FKCHARACTER>",this -> fkcharacter);
	dest += slask;
	sprintf(slask,"<FKTREE>%ld</FKTREE>",this -> fktree);
	dest += slask;
	dest += "</CHARACTERTREE>";
	return dest;
}


size_t CharacterTree::num_cols()
{
	return 3;
}


void CharacterTree::clear()
{
	this -> charactertreeid = 0;
	this -> fkcharacter = 0;
	this -> fktree = 0;
}


void CharacterTree::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select charactertreeid,fkCharacter,fkTree " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> charactertreeid = q.getval(0);																				// 0 - charactertreeid INTEGER
		this -> fkcharacter = q.getval(1);																				// 1 - fkcharacter INTEGER
		this -> fktree = q.getval(2);																				// 2 - fktree INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void CharacterTree::spawn(Query *qd,int offset)
{
	clear();

	this -> charactertreeid = qd -> getval(0 + offset);																				// 0 - charactertreeid INTEGER
	this -> fkcharacter = qd -> getval(1 + offset);																				// 1 - fkcharacter INTEGER
	this -> fktree = qd -> getval(2 + offset);																				// 2 - fktree INTEGER
}


// End of implementation of class 'CharacterTree'

} // End of namespace
namespace db {

/**
 **  Begin class 'Clusters'
 **/

Clusters::Clusters(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Clusters::Clusters(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Clusters::Clusters(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Clusters::Clusters(Database& db,long i_clusterid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Clusters where ";
	{
		char slask[100];
		sprintf(slask,"clusterid='%ld'",i_clusterid);
		sql += slask;
	}
	spawn(sql);
}


Clusters::~Clusters()
{
}


void Clusters::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Clusters::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Clusters(name)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	clusterid = inserted_id;
	return inserted_id;
}


void Clusters::update()
{
	update(this -> clusterid);
}


void Clusters::update(long i_clusterid)
{
	Query q(*database);
	std::string sql;
	sql += "update Clusters set name='" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[200];
		sprintf(slask," where clusterid='%ld'",i_clusterid);
		sql += slask;
	}
	q.execute(sql);
}


void Clusters::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Clusters::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Clusters where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," clusterid='%ld'",this -> clusterid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Clusters::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CLUSTERS>";
	sprintf(slask,"<CLUSTERID>%ld</CLUSTERID>",this -> clusterid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "</CLUSTERS>";
	return dest;
}


std::string Clusters::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<CLUSTERS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<CLUSTERID>%ld</CLUSTERID>",this -> clusterid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "</CLUSTERS>";
	return dest;
}


size_t Clusters::num_cols()
{
	return 2;
}


void Clusters::clear()
{
	this -> clusterid = 0;
	this -> name = "";
}


void Clusters::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select clusterid,name " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> clusterid = q.getval(0);																				// 0 - clusterid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Clusters::spawn(Query *qd,int offset)
{
	clear();

	this -> clusterid = qd -> getval(0 + offset);																				// 0 - clusterid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
}


// End of implementation of class 'Clusters'

} // End of namespace
namespace db {

/**
 **  Begin class 'Colours'
 **/

Colours::Colours(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Colours::Colours(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Colours::Colours(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Colours::Colours(Database& db,long i_colourid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Colours where ";
	{
		char slask[100];
		sprintf(slask,"colourid='%ld'",i_colourid);
		sql += slask;
	}
	spawn(sql);
}


Colours::~Colours()
{
}


void Colours::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Colours::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Colours(name,code,colourstring,ansi)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", '" + q.GetDatabase().safestr(this -> code) + "'";
	sql += ", '" + q.GetDatabase().safestr(this -> colourstring) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> ansi);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	colourid = inserted_id;
	return inserted_id;
}


void Colours::update()
{
	update(this -> colourid);
}


void Colours::update(long i_colourid)
{
	Query q(*database);
	std::string sql;
	sql += "update Colours set name='" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", code='" + q.GetDatabase().safestr(this -> code) + "'";
	sql += ", colourstring='" + q.GetDatabase().safestr(this -> colourstring) + "'";
	{
		char slask[200];
		sprintf(slask,", ansi=%ld",this -> ansi);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where colourid='%ld'",i_colourid);
		sql += slask;
	}
	q.execute(sql);
}


void Colours::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Colours::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Colours where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," colourid='%ld'",this -> colourid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Colours::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<COLOURS>";
	sprintf(slask,"<COLOURID>%ld</COLOURID>",this -> colourid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<CODE>" + q.GetDatabase().xmlsafestr(this -> code) + "</CODE>";
	dest += "<COLOURSTRING>" + q.GetDatabase().xmlsafestr(this -> colourstring) + "</COLOURSTRING>";
	sprintf(slask,"<ANSI>%ld</ANSI>",this -> ansi);
	dest += slask;
	dest += "</COLOURS>";
	return dest;
}


std::string Colours::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<COLOURS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<COLOURID>%ld</COLOURID>",this -> colourid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<CODE>" + q.GetDatabase().xmlsafestr(this -> code) + "</CODE>";
	dest += "<COLOURSTRING>" + q.GetDatabase().xmlsafestr(this -> colourstring) + "</COLOURSTRING>";
	sprintf(slask,"<ANSI>%ld</ANSI>",this -> ansi);
	dest += slask;
	dest += "</COLOURS>";
	return dest;
}


size_t Colours::num_cols()
{
	return 5;
}


void Colours::clear()
{
	this -> colourid = 0;
	this -> name = "";
	this -> code = "";
	this -> colourstring = "";
	this -> ansi = 0;
}


void Colours::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select colourid,name,code,colourstring,ansi " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> colourid = q.getval(0);																				// 0 - colourid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> code = q.getstr(2);																				// 2 - code TEXT
		this -> colourstring = q.getstr(3);																				// 3 - colourstring TEXT
		this -> ansi = q.getval(4);																				// 4 - ansi INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Colours::spawn(Query *qd,int offset)
{
	clear();

	this -> colourid = qd -> getval(0 + offset);																				// 0 - colourid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> code = qd -> getstr(2 + offset);																				// 2 - code TEXT
	this -> colourstring = qd -> getstr(3 + offset);																				// 3 - colourstring TEXT
	this -> ansi = qd -> getval(4 + offset);																				// 4 - ansi INTEGER
}


// End of implementation of class 'Colours'

} // End of namespace
namespace db {

/**
 **  Begin class 'Commands'
 **/

Commands::Commands(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Commands::Commands(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Commands::Commands(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Commands::Commands(Database& db,long i_commandid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Commands where ";
	{
		char slask[100];
		sprintf(slask,"commandid='%ld'",i_commandid);
		sql += slask;
	}
	spawn(sql);
}


Commands::~Commands()
{
}


void Commands::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Commands::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Commands(name,grantgroup,highforce,force,lowforce)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> grantgroup);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> highforce);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> force);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> lowforce);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	commandid = inserted_id;
	return inserted_id;
}


void Commands::update()
{
	update(this -> commandid);
}


void Commands::update(long i_commandid)
{
	Query q(*database);
	std::string sql;
	sql += "update Commands set name='" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[200];
		sprintf(slask,", grantgroup=%ld",this -> grantgroup);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", highforce=%ld",this -> highforce);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", force=%ld",this -> force);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", lowforce=%ld",this -> lowforce);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where commandid='%ld'",i_commandid);
		sql += slask;
	}
	q.execute(sql);
}


void Commands::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Commands::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Commands where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," commandid='%ld'",this -> commandid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Commands::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<COMMANDS>";
	sprintf(slask,"<COMMANDID>%ld</COMMANDID>",this -> commandid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<GRANTGROUP>%ld</GRANTGROUP>",this -> grantgroup);
	dest += slask;
	sprintf(slask,"<HIGHFORCE>%ld</HIGHFORCE>",this -> highforce);
	dest += slask;
	sprintf(slask,"<FORCE>%ld</FORCE>",this -> force);
	dest += slask;
	sprintf(slask,"<LOWFORCE>%ld</LOWFORCE>",this -> lowforce);
	dest += slask;
	dest += "</COMMANDS>";
	return dest;
}


std::string Commands::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<COMMANDS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<COMMANDID>%ld</COMMANDID>",this -> commandid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<GRANTGROUP>%ld</GRANTGROUP>",this -> grantgroup);
	dest += slask;
	sprintf(slask,"<HIGHFORCE>%ld</HIGHFORCE>",this -> highforce);
	dest += slask;
	sprintf(slask,"<FORCE>%ld</FORCE>",this -> force);
	dest += slask;
	sprintf(slask,"<LOWFORCE>%ld</LOWFORCE>",this -> lowforce);
	dest += slask;
	dest += "</COMMANDS>";
	return dest;
}


size_t Commands::num_cols()
{
	return 6;
}


void Commands::clear()
{
	this -> commandid = 0;
	this -> name = "";
	this -> grantgroup = 0;
	this -> highforce = 0;
	this -> force = 0;
	this -> lowforce = 0;
}


void Commands::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select commandid,name,grantgroup,highforce,force,lowforce " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> commandid = q.getval(0);																				// 0 - commandid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> grantgroup = q.getval(2);																				// 2 - grantgroup INTEGER
		this -> highforce = q.getval(3);																				// 3 - highforce INTEGER
		this -> force = q.getval(4);																				// 4 - force INTEGER
		this -> lowforce = q.getval(5);																				// 5 - lowforce INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Commands::spawn(Query *qd,int offset)
{
	clear();

	this -> commandid = qd -> getval(0 + offset);																				// 0 - commandid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> grantgroup = qd -> getval(2 + offset);																				// 2 - grantgroup INTEGER
	this -> highforce = qd -> getval(3 + offset);																				// 3 - highforce INTEGER
	this -> force = qd -> getval(4 + offset);																				// 4 - force INTEGER
	this -> lowforce = qd -> getval(5 + offset);																				// 5 - lowforce INTEGER
}


// End of implementation of class 'Commands'

} // End of namespace
namespace db {

/**
 **  Begin class 'Exits'
 **/

Exits::Exits(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Exits::Exits(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Exits::Exits(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Exits::Exits(Database& db,long i_exitid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Exits where ";
	{
		char slask[100];
		sprintf(slask,"exitid='%ld'",i_exitid);
		sql += slask;
	}
	spawn(sql);
}


Exits::~Exits()
{
}


void Exits::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Exits::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Exits(dir)";
	{
		char slask[100];
		sprintf(slask," values(%ld",this -> dir);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	exitid = inserted_id;
	return inserted_id;
}


void Exits::update()
{
	update(this -> exitid);
}


void Exits::update(long i_exitid)
{
	Query q(*database);
	std::string sql;
	{
		char slask[200];
		sprintf(slask,"update Exits set dir=%ld",this -> dir);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where exitid='%ld'",i_exitid);
		sql += slask;
	}
	q.execute(sql);
}


void Exits::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Exits::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Exits where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," exitid='%ld'",this -> exitid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Exits::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<EXITS>";
	sprintf(slask,"<EXITID>%ld</EXITID>",this -> exitid);
	dest += slask;
	sprintf(slask,"<DIR>%ld</DIR>",this -> dir);
	dest += slask;
	dest += "</EXITS>";
	return dest;
}


std::string Exits::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<EXITS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<EXITID>%ld</EXITID>",this -> exitid);
	dest += slask;
	sprintf(slask,"<DIR>%ld</DIR>",this -> dir);
	dest += slask;
	dest += "</EXITS>";
	return dest;
}


size_t Exits::num_cols()
{
	return 2;
}


void Exits::clear()
{
	this -> exitid = 0;
	this -> dir = 0;
}


void Exits::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select exitid,dir " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> exitid = q.getval(0);																				// 0 - exitid INTEGER
		this -> dir = q.getval(1);																				// 1 - dir INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Exits::spawn(Query *qd,int offset)
{
	clear();

	this -> exitid = qd -> getval(0 + offset);																				// 0 - exitid INTEGER
	this -> dir = qd -> getval(1 + offset);																				// 1 - dir INTEGER
}


// End of implementation of class 'Exits'

} // End of namespace
namespace db {

/**
 **  Begin class 'GrantGroups'
 **/

GrantGroups::GrantGroups(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


GrantGroups::GrantGroups(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


GrantGroups::GrantGroups(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


GrantGroups::GrantGroups(Database& db,long i_grantgroupid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from GrantGroups where ";
	{
		char slask[100];
		sprintf(slask,"grantgroupid='%ld'",i_grantgroupid);
		sql += slask;
	}
	spawn(sql);
}


GrantGroups::~GrantGroups()
{
}


void GrantGroups::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long GrantGroups::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into GrantGroups(name,defaultgrant,implies)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> defaultgrant);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> implies);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	grantgroupid = inserted_id;
	return inserted_id;
}


void GrantGroups::update()
{
	update(this -> grantgroupid);
}


void GrantGroups::update(long i_grantgroupid)
{
	Query q(*database);
	std::string sql;
	sql += "update GrantGroups set name='" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[200];
		sprintf(slask,", defaultgrant=%ld",this -> defaultgrant);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", implies=%ld",this -> implies);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where grantgroupid='%ld'",i_grantgroupid);
		sql += slask;
	}
	q.execute(sql);
}


void GrantGroups::save()
{
	if (new_object)
		insert();
	else
		update();
}


void GrantGroups::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from GrantGroups where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," grantgroupid='%ld'",this -> grantgroupid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string GrantGroups::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<GRANTGROUPS>";
	sprintf(slask,"<GRANTGROUPID>%ld</GRANTGROUPID>",this -> grantgroupid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<DEFAULTGRANT>%ld</DEFAULTGRANT>",this -> defaultgrant);
	dest += slask;
	sprintf(slask,"<IMPLIES>%ld</IMPLIES>",this -> implies);
	dest += slask;
	dest += "</GRANTGROUPS>";
	return dest;
}


std::string GrantGroups::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<GRANTGROUPS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<GRANTGROUPID>%ld</GRANTGROUPID>",this -> grantgroupid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<DEFAULTGRANT>%ld</DEFAULTGRANT>",this -> defaultgrant);
	dest += slask;
	sprintf(slask,"<IMPLIES>%ld</IMPLIES>",this -> implies);
	dest += slask;
	dest += "</GRANTGROUPS>";
	return dest;
}


size_t GrantGroups::num_cols()
{
	return 4;
}


void GrantGroups::clear()
{
	this -> grantgroupid = 0;
	this -> name = "";
	this -> defaultgrant = 0;
	this -> implies = 0;
}


void GrantGroups::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select grantgroupid,name,defaultgrant,implies " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> grantgroupid = q.getval(0);																				// 0 - grantgroupid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> defaultgrant = q.getval(2);																				// 2 - defaultgrant INTEGER
		this -> implies = q.getval(3);																				// 3 - implies INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void GrantGroups::spawn(Query *qd,int offset)
{
	clear();

	this -> grantgroupid = qd -> getval(0 + offset);																				// 0 - grantgroupid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> defaultgrant = qd -> getval(2 + offset);																				// 2 - defaultgrant INTEGER
	this -> implies = qd -> getval(3 + offset);																				// 3 - implies INTEGER
}


// End of implementation of class 'GrantGroups'

} // End of namespace
namespace db {

/**
 **  Begin class 'Permissions'
 **/

Permissions::Permissions(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Permissions::Permissions(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Permissions::Permissions(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Permissions::Permissions(Database& db,long i_permissionid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Permissions where ";
	{
		char slask[100];
		sprintf(slask,"permissionid='%ld'",i_permissionid);
		sql += slask;
	}
	spawn(sql);
}


Permissions::~Permissions()
{
}


void Permissions::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Permissions::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Permissions(fkAccount,fkCommand,fkGrantGroup,grant)";
	{
		char slask[100];
		sprintf(slask," values(%ld",this -> fkaccount);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkcommand);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkgrantgroup);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> grant);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	permissionid = inserted_id;
	return inserted_id;
}


void Permissions::update()
{
	update(this -> permissionid);
}


void Permissions::update(long i_permissionid)
{
	Query q(*database);
	std::string sql;
	{
		char slask[200];
		sprintf(slask,"update Permissions set fkAccount=%ld",this -> fkaccount);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkCommand=%ld",this -> fkcommand);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkGrantGroup=%ld",this -> fkgrantgroup);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", grant=%ld",this -> grant);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where permissionid='%ld'",i_permissionid);
		sql += slask;
	}
	q.execute(sql);
}


void Permissions::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Permissions::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Permissions where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," permissionid='%ld'",this -> permissionid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Permissions::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<PERMISSIONS>";
	sprintf(slask,"<PERMISSIONID>%ld</PERMISSIONID>",this -> permissionid);
	dest += slask;
	sprintf(slask,"<FKACCOUNT>%ld</FKACCOUNT>",this -> fkaccount);
	dest += slask;
	sprintf(slask,"<FKCOMMAND>%ld</FKCOMMAND>",this -> fkcommand);
	dest += slask;
	sprintf(slask,"<FKGRANTGROUP>%ld</FKGRANTGROUP>",this -> fkgrantgroup);
	dest += slask;
	sprintf(slask,"<GRANT>%ld</GRANT>",this -> grant);
	dest += slask;
	dest += "</PERMISSIONS>";
	return dest;
}


std::string Permissions::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<PERMISSIONS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<PERMISSIONID>%ld</PERMISSIONID>",this -> permissionid);
	dest += slask;
	sprintf(slask,"<FKACCOUNT>%ld</FKACCOUNT>",this -> fkaccount);
	dest += slask;
	sprintf(slask,"<FKCOMMAND>%ld</FKCOMMAND>",this -> fkcommand);
	dest += slask;
	sprintf(slask,"<FKGRANTGROUP>%ld</FKGRANTGROUP>",this -> fkgrantgroup);
	dest += slask;
	sprintf(slask,"<GRANT>%ld</GRANT>",this -> grant);
	dest += slask;
	dest += "</PERMISSIONS>";
	return dest;
}


size_t Permissions::num_cols()
{
	return 5;
}


void Permissions::clear()
{
	this -> permissionid = 0;
	this -> fkaccount = 0;
	this -> fkcommand = 0;
	this -> fkgrantgroup = 0;
	this -> grant = 0;
}


void Permissions::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select permissionid,fkAccount,fkCommand,fkGrantGroup,grant " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> permissionid = q.getval(0);																				// 0 - permissionid INTEGER
		this -> fkaccount = q.getval(1);																				// 1 - fkaccount INTEGER
		this -> fkcommand = q.getval(2);																				// 2 - fkcommand INTEGER
		this -> fkgrantgroup = q.getval(3);																				// 3 - fkgrantgroup INTEGER
		this -> grant = q.getval(4);																				// 4 - grant INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Permissions::spawn(Query *qd,int offset)
{
	clear();

	this -> permissionid = qd -> getval(0 + offset);																				// 0 - permissionid INTEGER
	this -> fkaccount = qd -> getval(1 + offset);																				// 1 - fkaccount INTEGER
	this -> fkcommand = qd -> getval(2 + offset);																				// 2 - fkcommand INTEGER
	this -> fkgrantgroup = qd -> getval(3 + offset);																				// 3 - fkgrantgroup INTEGER
	this -> grant = qd -> getval(4 + offset);																				// 4 - grant INTEGER
}


// End of implementation of class 'Permissions'

} // End of namespace
namespace db {

/**
 **  Begin class 'Races'
 **/

Races::Races(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Races::Races(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Races::Races(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Races::Races(Database& db,long i_raceid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Races where ";
	{
		char slask[100];
		sprintf(slask,"raceid='%ld'",i_raceid);
		sql += slask;
	}
	spawn(sql);
}


Races::~Races()
{
}


void Races::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Races::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Races(name)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	raceid = inserted_id;
	return inserted_id;
}


void Races::update()
{
	update(this -> raceid);
}


void Races::update(long i_raceid)
{
	Query q(*database);
	std::string sql;
	sql += "update Races set name='" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[200];
		sprintf(slask," where raceid='%ld'",i_raceid);
		sql += slask;
	}
	q.execute(sql);
}


void Races::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Races::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Races where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," raceid='%ld'",this -> raceid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Races::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<RACES>";
	sprintf(slask,"<RACEID>%ld</RACEID>",this -> raceid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "</RACES>";
	return dest;
}


std::string Races::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<RACES " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<RACEID>%ld</RACEID>",this -> raceid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "</RACES>";
	return dest;
}


size_t Races::num_cols()
{
	return 2;
}


void Races::clear()
{
	this -> raceid = 0;
	this -> name = "";
}


void Races::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select raceid,name " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> raceid = q.getval(0);																				// 0 - raceid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Races::spawn(Query *qd,int offset)
{
	clear();

	this -> raceid = qd -> getval(0 + offset);																				// 0 - raceid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
}


// End of implementation of class 'Races'

} // End of namespace
namespace db {

/**
 **  Begin class 'Rooms'
 **/

Rooms::Rooms(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Rooms::Rooms(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Rooms::Rooms(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Rooms::Rooms(Database& db,long i_roomid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Rooms where ";
	{
		char slask[100];
		sprintf(slask,"roomid='%ld'",i_roomid);
		sql += slask;
	}
	spawn(sql);
}


Rooms::~Rooms()
{
}


void Rooms::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Rooms::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Rooms(name,description,fkArea,fkSector,width,length,height)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", '" + q.GetDatabase().safestr(this -> description) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkarea);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fksector);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> width);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> length);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> height);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	roomid = inserted_id;
	return inserted_id;
}


void Rooms::update()
{
	update(this -> roomid);
}


void Rooms::update(long i_roomid)
{
	Query q(*database);
	std::string sql;
	sql += "update Rooms set name='" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", description='" + q.GetDatabase().safestr(this -> description) + "'";
	{
		char slask[200];
		sprintf(slask,", fkArea=%ld",this -> fkarea);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkSector=%ld",this -> fksector);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", width=%ld",this -> width);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", length=%ld",this -> length);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", height=%ld",this -> height);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where roomid='%ld'",i_roomid);
		sql += slask;
	}
	q.execute(sql);
}


void Rooms::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Rooms::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Rooms where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," roomid='%ld'",this -> roomid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Rooms::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<ROOMS>";
	sprintf(slask,"<ROOMID>%ld</ROOMID>",this -> roomid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<DESCRIPTION>" + q.GetDatabase().xmlsafestr(this -> description) + "</DESCRIPTION>";
	sprintf(slask,"<FKAREA>%ld</FKAREA>",this -> fkarea);
	dest += slask;
	sprintf(slask,"<FKSECTOR>%ld</FKSECTOR>",this -> fksector);
	dest += slask;
	sprintf(slask,"<WIDTH>%ld</WIDTH>",this -> width);
	dest += slask;
	sprintf(slask,"<LENGTH>%ld</LENGTH>",this -> length);
	dest += slask;
	sprintf(slask,"<HEIGHT>%ld</HEIGHT>",this -> height);
	dest += slask;
	dest += "</ROOMS>";
	return dest;
}


std::string Rooms::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<ROOMS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<ROOMID>%ld</ROOMID>",this -> roomid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<DESCRIPTION>" + q.GetDatabase().xmlsafestr(this -> description) + "</DESCRIPTION>";
	sprintf(slask,"<FKAREA>%ld</FKAREA>",this -> fkarea);
	dest += slask;
	sprintf(slask,"<FKSECTOR>%ld</FKSECTOR>",this -> fksector);
	dest += slask;
	sprintf(slask,"<WIDTH>%ld</WIDTH>",this -> width);
	dest += slask;
	sprintf(slask,"<LENGTH>%ld</LENGTH>",this -> length);
	dest += slask;
	sprintf(slask,"<HEIGHT>%ld</HEIGHT>",this -> height);
	dest += slask;
	dest += "</ROOMS>";
	return dest;
}


size_t Rooms::num_cols()
{
	return 8;
}


void Rooms::clear()
{
	this -> roomid = 0;
	this -> name = "";
	this -> description = "";
	this -> fkarea = 0;
	this -> fksector = 0;
	this -> width = 0;
	this -> length = 0;
	this -> height = 0;
}


void Rooms::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select roomid,name,description,fkArea,fkSector,width,length,height " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> roomid = q.getval(0);																				// 0 - roomid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> description = q.getstr(2);																				// 2 - description TEXT
		this -> fkarea = q.getval(3);																				// 3 - fkarea INTEGER
		this -> fksector = q.getval(4);																				// 4 - fksector INTEGER
		this -> width = q.getval(5);																				// 5 - width INTEGER
		this -> length = q.getval(6);																				// 6 - length INTEGER
		this -> height = q.getval(7);																				// 7 - height INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Rooms::spawn(Query *qd,int offset)
{
	clear();

	this -> roomid = qd -> getval(0 + offset);																				// 0 - roomid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> description = qd -> getstr(2 + offset);																				// 2 - description TEXT
	this -> fkarea = qd -> getval(3 + offset);																				// 3 - fkarea INTEGER
	this -> fksector = qd -> getval(4 + offset);																				// 4 - fksector INTEGER
	this -> width = qd -> getval(5 + offset);																				// 5 - width INTEGER
	this -> length = qd -> getval(6 + offset);																				// 6 - length INTEGER
	this -> height = qd -> getval(7 + offset);																				// 7 - height INTEGER
}


// End of implementation of class 'Rooms'

} // End of namespace
namespace db {

/**
 **  Begin class 'Sectors'
 **/

Sectors::Sectors(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Sectors::Sectors(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Sectors::Sectors(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Sectors::Sectors(Database& db,long i_sectorid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Sectors where ";
	{
		char slask[100];
		sprintf(slask,"sectorid='%ld'",i_sectorid);
		sql += slask;
	}
	spawn(sql);
}


Sectors::~Sectors()
{
}


void Sectors::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Sectors::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Sectors(name,symbol,movecost,water)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", '" + q.GetDatabase().safestr(this -> symbol) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> movecost);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> water);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	sectorid = inserted_id;
	return inserted_id;
}


void Sectors::update()
{
	update(this -> sectorid);
}


void Sectors::update(long i_sectorid)
{
	Query q(*database);
	std::string sql;
	sql += "update Sectors set name='" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", symbol='" + q.GetDatabase().safestr(this -> symbol) + "'";
	{
		char slask[200];
		sprintf(slask,", movecost=%ld",this -> movecost);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", water=%ld",this -> water);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where sectorid='%ld'",i_sectorid);
		sql += slask;
	}
	q.execute(sql);
}


void Sectors::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Sectors::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Sectors where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," sectorid='%ld'",this -> sectorid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Sectors::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<SECTORS>";
	sprintf(slask,"<SECTORID>%ld</SECTORID>",this -> sectorid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<SYMBOL>" + q.GetDatabase().xmlsafestr(this -> symbol) + "</SYMBOL>";
	sprintf(slask,"<MOVECOST>%ld</MOVECOST>",this -> movecost);
	dest += slask;
	sprintf(slask,"<WATER>%ld</WATER>",this -> water);
	dest += slask;
	dest += "</SECTORS>";
	return dest;
}


std::string Sectors::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<SECTORS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<SECTORID>%ld</SECTORID>",this -> sectorid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<SYMBOL>" + q.GetDatabase().xmlsafestr(this -> symbol) + "</SYMBOL>";
	sprintf(slask,"<MOVECOST>%ld</MOVECOST>",this -> movecost);
	dest += slask;
	sprintf(slask,"<WATER>%ld</WATER>",this -> water);
	dest += slask;
	dest += "</SECTORS>";
	return dest;
}


size_t Sectors::num_cols()
{
	return 5;
}


void Sectors::clear()
{
	this -> sectorid = 0;
	this -> name = "";
	this -> symbol = "";
	this -> movecost = 0;
	this -> water = 0;
}


void Sectors::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select sectorid,name,symbol,movecost,water " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> sectorid = q.getval(0);																				// 0 - sectorid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> symbol = q.getstr(2);																				// 2 - symbol TEXT
		this -> movecost = q.getval(3);																				// 3 - movecost INTEGER
		this -> water = q.getval(4);																				// 4 - water INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Sectors::spawn(Query *qd,int offset)
{
	clear();

	this -> sectorid = qd -> getval(0 + offset);																				// 0 - sectorid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> symbol = qd -> getstr(2 + offset);																				// 2 - symbol TEXT
	this -> movecost = qd -> getval(3 + offset);																				// 3 - movecost INTEGER
	this -> water = qd -> getval(4 + offset);																				// 4 - water INTEGER
}


// End of implementation of class 'Sectors'

} // End of namespace
namespace db {

/**
 **  Begin class 'Skills'
 **/

Skills::Skills(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Skills::Skills(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Skills::Skills(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Skills::Skills(Database& db,long i_skillid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Skills where ";
	{
		char slask[100];
		sprintf(slask,"skillid='%ld'",i_skillid);
		sql += slask;
	}
	spawn(sql);
}


Skills::~Skills()
{
}


void Skills::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Skills::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Skills(name,fkBranch)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkbranch);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	skillid = inserted_id;
	return inserted_id;
}


void Skills::update()
{
	update(this -> skillid);
}


void Skills::update(long i_skillid)
{
	Query q(*database);
	std::string sql;
	sql += "update Skills set name='" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[200];
		sprintf(slask,", fkBranch=%ld",this -> fkbranch);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where skillid='%ld'",i_skillid);
		sql += slask;
	}
	q.execute(sql);
}


void Skills::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Skills::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Skills where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," skillid='%ld'",this -> skillid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Skills::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<SKILLS>";
	sprintf(slask,"<SKILLID>%ld</SKILLID>",this -> skillid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<FKBRANCH>%ld</FKBRANCH>",this -> fkbranch);
	dest += slask;
	dest += "</SKILLS>";
	return dest;
}


std::string Skills::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<SKILLS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<SKILLID>%ld</SKILLID>",this -> skillid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<FKBRANCH>%ld</FKBRANCH>",this -> fkbranch);
	dest += slask;
	dest += "</SKILLS>";
	return dest;
}


size_t Skills::num_cols()
{
	return 3;
}


void Skills::clear()
{
	this -> skillid = 0;
	this -> name = "";
	this -> fkbranch = 0;
}


void Skills::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select skillid,name,fkBranch " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> skillid = q.getval(0);																				// 0 - skillid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> fkbranch = q.getval(2);																				// 2 - fkbranch INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Skills::spawn(Query *qd,int offset)
{
	clear();

	this -> skillid = qd -> getval(0 + offset);																				// 0 - skillid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> fkbranch = qd -> getval(2 + offset);																				// 2 - fkbranch INTEGER
}


// End of implementation of class 'Skills'

} // End of namespace
namespace db {

/**
 **  Begin class 'Stats'
 **/

Stats::Stats(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Stats::Stats(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Stats::Stats(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Stats::Stats(Database& db,long i_statid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Stats where ";
	{
		char slask[100];
		sprintf(slask,"statid='%ld'",i_statid);
		sql += slask;
	}
	spawn(sql);
}


Stats::~Stats()
{
}


void Stats::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Stats::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Stats(name,shortname)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", '" + q.GetDatabase().safestr(this -> shortname) + "'";
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	statid = inserted_id;
	return inserted_id;
}


void Stats::update()
{
	update(this -> statid);
}


void Stats::update(long i_statid)
{
	Query q(*database);
	std::string sql;
	sql += "update Stats set name='" + q.GetDatabase().safestr(this -> name) + "'";
	sql += ", shortname='" + q.GetDatabase().safestr(this -> shortname) + "'";
	{
		char slask[200];
		sprintf(slask," where statid='%ld'",i_statid);
		sql += slask;
	}
	q.execute(sql);
}


void Stats::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Stats::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Stats where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," statid='%ld'",this -> statid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Stats::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<STATS>";
	sprintf(slask,"<STATID>%ld</STATID>",this -> statid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<SHORTNAME>" + q.GetDatabase().xmlsafestr(this -> shortname) + "</SHORTNAME>";
	dest += "</STATS>";
	return dest;
}


std::string Stats::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<STATS " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<STATID>%ld</STATID>",this -> statid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	dest += "<SHORTNAME>" + q.GetDatabase().xmlsafestr(this -> shortname) + "</SHORTNAME>";
	dest += "</STATS>";
	return dest;
}


size_t Stats::num_cols()
{
	return 3;
}


void Stats::clear()
{
	this -> statid = 0;
	this -> name = "";
	this -> shortname = "";
}


void Stats::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select statid,name,shortname " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> statid = q.getval(0);																				// 0 - statid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> shortname = q.getstr(2);																				// 2 - shortname TEXT
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Stats::spawn(Query *qd,int offset)
{
	clear();

	this -> statid = qd -> getval(0 + offset);																				// 0 - statid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> shortname = qd -> getstr(2 + offset);																				// 2 - shortname TEXT
}


// End of implementation of class 'Stats'

} // End of namespace
namespace db {

/**
 **  Begin class 'Trees'
 **/

Trees::Trees(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Trees::Trees(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Trees::Trees(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Trees::Trees(Database& db,long i_treeid):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Trees where ";
	{
		char slask[100];
		sprintf(slask,"treeid='%ld'",i_treeid);
		sql += slask;
	}
	spawn(sql);
}


Trees::~Trees()
{
}


void Trees::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Trees::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Trees(name,fkCluster,fkPrimaryStat,fkSecondaryStat)";
	sql += " values('" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkcluster);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fkprimarystat);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> fksecondarystat);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	treeid = inserted_id;
	return inserted_id;
}


void Trees::update()
{
	update(this -> treeid);
}


void Trees::update(long i_treeid)
{
	Query q(*database);
	std::string sql;
	sql += "update Trees set name='" + q.GetDatabase().safestr(this -> name) + "'";
	{
		char slask[200];
		sprintf(slask,", fkCluster=%ld",this -> fkcluster);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkPrimaryStat=%ld",this -> fkprimarystat);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", fkSecondaryStat=%ld",this -> fksecondarystat);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where treeid='%ld'",i_treeid);
		sql += slask;
	}
	q.execute(sql);
}


void Trees::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Trees::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Trees where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," treeid='%ld'",this -> treeid);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Trees::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<TREES>";
	sprintf(slask,"<TREEID>%ld</TREEID>",this -> treeid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<FKCLUSTER>%ld</FKCLUSTER>",this -> fkcluster);
	dest += slask;
	sprintf(slask,"<FKPRIMARYSTAT>%ld</FKPRIMARYSTAT>",this -> fkprimarystat);
	dest += slask;
	sprintf(slask,"<FKSECONDARYSTAT>%ld</FKSECONDARYSTAT>",this -> fksecondarystat);
	dest += slask;
	dest += "</TREES>";
	return dest;
}


std::string Trees::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<TREES " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<TREEID>%ld</TREEID>",this -> treeid);
	dest += slask;
	dest += "<NAME>" + q.GetDatabase().xmlsafestr(this -> name) + "</NAME>";
	sprintf(slask,"<FKCLUSTER>%ld</FKCLUSTER>",this -> fkcluster);
	dest += slask;
	sprintf(slask,"<FKPRIMARYSTAT>%ld</FKPRIMARYSTAT>",this -> fkprimarystat);
	dest += slask;
	sprintf(slask,"<FKSECONDARYSTAT>%ld</FKSECONDARYSTAT>",this -> fksecondarystat);
	dest += slask;
	dest += "</TREES>";
	return dest;
}


size_t Trees::num_cols()
{
	return 5;
}


void Trees::clear()
{
	this -> treeid = 0;
	this -> name = "";
	this -> fkcluster = 0;
	this -> fkprimarystat = 0;
	this -> fksecondarystat = 0;
}


void Trees::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select treeid,name,fkCluster,fkPrimaryStat,fkSecondaryStat " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> treeid = q.getval(0);																				// 0 - treeid INTEGER
		this -> name = q.getstr(1);																				// 1 - name TEXT
		this -> fkcluster = q.getval(2);																				// 2 - fkcluster INTEGER
		this -> fkprimarystat = q.getval(3);																				// 3 - fkprimarystat INTEGER
		this -> fksecondarystat = q.getval(4);																				// 4 - fksecondarystat INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Trees::spawn(Query *qd,int offset)
{
	clear();

	this -> treeid = qd -> getval(0 + offset);																				// 0 - treeid INTEGER
	this -> name = qd -> getstr(1 + offset);																				// 1 - name TEXT
	this -> fkcluster = qd -> getval(2 + offset);																				// 2 - fkcluster INTEGER
	this -> fkprimarystat = qd -> getval(3 + offset);																				// 3 - fkprimarystat INTEGER
	this -> fksecondarystat = qd -> getval(4 + offset);																				// 4 - fksecondarystat INTEGER
}


// End of implementation of class 'Trees'

} // End of namespace
namespace db {

/**
 **  Begin class 'Version'
 **/

Version::Version(Database *db)
{
	database = db;
	new_object = 1;
	clear();
}


Version::Version(Database *db,const std::string& sql)
{
	database = db;
	new_object = 1;
	spawn(sql);
}


Version::Version(Database *db,Query *qd,int offset)
{
	database = db;
	new_object = 0;
	spawn(qd, offset);
}


Version::Version(Database& db,long i_version):database(&db),new_object(1)
{
	Query q(*database);
	std::string sql = "select * from Version where ";
	{
		char slask[100];
		sprintf(slask,"version='%ld'",i_version);
		sql += slask;
	}
	spawn(sql);
}


Version::~Version()
{
}


void Version::select(const std::string& sql)
{
	spawn(sql);
}


unsigned long Version::insert()
{
	Query q(*database);
	std::string sql;

	sql = "insert into Version(versiontext,major,minor,micro)";
	sql += " values('" + q.GetDatabase().safestr(this -> versiontext) + "'";
	{
		char slask[100];
		sprintf(slask,", %ld",this -> major);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> minor);
		sql += slask;
	}
	{
		char slask[100];
		sprintf(slask,", %ld",this -> micro);
		sql += slask;
	}
	sql += ")";
	q.execute(sql);
	new_object = 0;
	unsigned long inserted_id = (unsigned long)q.insert_id();
	version = inserted_id;
	return inserted_id;
}


void Version::update()
{
	update(this -> version);
}


void Version::update(long i_version)
{
	Query q(*database);
	std::string sql;
	sql += "update Version set versiontext='" + q.GetDatabase().safestr(this -> versiontext) + "'";
	{
		char slask[200];
		sprintf(slask,", major=%ld",this -> major);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", minor=%ld",this -> minor);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask,", micro=%ld",this -> micro);
		sql += slask;
	}
	{
		char slask[200];
		sprintf(slask," where version='%ld'",i_version);
		sql += slask;
	}
	q.execute(sql);
}


void Version::save()
{
	if (new_object)
		insert();
	else
		update();
}


void Version::erase()
{
	if (!new_object)
	{
		std::string sql = "delete from Version where";
		Query q(*database);
		{
			char slask[200];
			sprintf(slask," version='%ld'",this -> version);
			sql += slask;
		}
		q.execute(sql);
	}
}


std::string Version::xml()
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<VERSION>";
	sprintf(slask,"<VERSION>%ld</VERSION>",this -> version);
	dest += slask;
	dest += "<VERSIONTEXT>" + q.GetDatabase().xmlsafestr(this -> versiontext) + "</VERSIONTEXT>";
	sprintf(slask,"<MAJOR>%ld</MAJOR>",this -> major);
	dest += slask;
	sprintf(slask,"<MINOR>%ld</MINOR>",this -> minor);
	dest += slask;
	sprintf(slask,"<MICRO>%ld</MICRO>",this -> micro);
	dest += slask;
	dest += "</VERSION>";
	return dest;
}


std::string Version::xml(const std::string& tag,const std::string& xvalx)
{
	Query q(*database);
	std::string dest;
	char slask[200];
	dest = "<VERSION " + tag + "=\"" + xvalx + "\">";
	sprintf(slask,"<VERSION>%ld</VERSION>",this -> version);
	dest += slask;
	dest += "<VERSIONTEXT>" + q.GetDatabase().xmlsafestr(this -> versiontext) + "</VERSIONTEXT>";
	sprintf(slask,"<MAJOR>%ld</MAJOR>",this -> major);
	dest += slask;
	sprintf(slask,"<MINOR>%ld</MINOR>",this -> minor);
	dest += slask;
	sprintf(slask,"<MICRO>%ld</MICRO>",this -> micro);
	dest += slask;
	dest += "</VERSION>";
	return dest;
}


size_t Version::num_cols()
{
	return 5;
}


void Version::clear()
{
	this -> version = 0;
	this -> versiontext = "";
	this -> major = 0;
	this -> minor = 0;
	this -> micro = 0;
}


void Version::spawn(const std::string& sql)
{
	Query q(*database);
	std::string temp;

	clear();

	if (!strncasecmp(sql.c_str(),"select * ",9))
	{
		temp = "select version,versiontext,major,minor,micro " + sql.substr(9);
	} else
		temp = sql;
	q.get_result(temp);
	if (q.fetch_row())
	{
		this -> version = q.getval(0);																				// 0 - version INTEGER
		this -> versiontext = q.getstr(1);																				// 1 - versiontext TEXT
		this -> major = q.getval(2);																				// 2 - major INTEGER
		this -> minor = q.getval(3);																				// 3 - minor INTEGER
		this -> micro = q.getval(4);																				// 4 - micro INTEGER
		new_object = 0;
	} else
		clear();
	q.free_result();
}


void Version::spawn(Query *qd,int offset)
{
	clear();

	this -> version = qd -> getval(0 + offset);																				// 0 - version INTEGER
	this -> versiontext = qd -> getstr(1 + offset);																				// 1 - versiontext TEXT
	this -> major = qd -> getval(2 + offset);																				// 2 - major INTEGER
	this -> minor = qd -> getval(3 + offset);																				// 3 - minor INTEGER
	this -> micro = qd -> getval(4 + offset);																				// 4 - micro INTEGER
}


// End of implementation of class 'Version'

} // End of namespace
